5A345760-A360-39C6-AF6A-C05975B11C0A-HS5AHTTTMKQYJQ/QWWDQRYIWZJUJVKXLV5N7JNIVUZC=

根据数据编写程序
--------

 作为一个初级程序员，是需要通过学习来提升自己，但是需要学习的知识点太多，jvm，mysql，网络，多线程，分布式，大数据。。。。根本记不下来，所以我一直在想，这些知识点之间的联系是什么？这些知识点该怎么记忆，在大脑中的知识不零碎，面试官问起时可以快速答上来。把我们的大脑记忆比喻成计算机的硬盘，就像是把这些怎样数据放入一块硬盘中，可以快速读取。其实怎样做，已经有答案了，就是建“索引”，在电脑中建索引可以根据某个字段建，那么这些知识点的索引是什么？是什么把这些知识点串起来的？

 答案是什么，也许各有各异，没有唯一的答案。但是偶然情况下听到Linus说过，“要根据数据写程序。”忽然我觉得恍然大悟，那就是数据，这索引就是“数据”，在之前学习的时候一直去记什么是多线程，什么是mysql索引，可是记了前面有忘了后面，关键是没有理解这些技术，并且思考的方向有错。之前的思考方向是这个技术怎么用，怎样处理数据，看api，看实现原理吧啦吧啦。。。好像这种思考方式也没错，典型程序猿思考方式，但是大神好像不是这样子想的。这是数据，有多大？什么规律？增长速度怎样？然后写程序和找框架。

 举个栗子，呃，可以上街随便找个程序猿，出一道题，“我有一个班级的数据，我要记下来这些信息，该怎么做？”。可能很多回答，用mysql，建个表@\#¥¥%% 其实我觉得会不会用一个txt会更好？或者SQlite?那这样子的话，这些技术的细节，是不是可以用数据串起来。一开始的时候数据不多不复杂，只是想用来做简单的加减乘除，只是希望可以跨平台，jvm出现啦。后来数据开始稍微复杂了，有了java的集合，后来有了网络，并发，spirng，分布式，大数据。。。。其实知识点还是那些知识点，知识观点不一样了，从数据特点出发，看技术的方案，而不是从技术特点来找数据。这文章的作用就是归类记忆

### 0 jvm虚拟机

###  0.1 jvm的雏形

 好几十年前，就二十年前吧，计算机不多，数据也不多，人们只是想用程序来做一些简单的操作，但是当时计算机操作系统和底层硬件不统一，所以很难做到同一段程序运行出来同一个结果。（很奇怪吗？因为当时用得最多就是c语言，而c语言在不同平台上运行会有差异），所以我们写一个程序，希望可以处理数据在不同平台上的一致性问题。by the way ,用c语言会导致跨平台不一致问题，用c语言写的虚拟机就不会，是不是很搞笑？就像是自来水是不能喝的，但是用自来水洗过的苹果是能吃的，下面来研究研究。

 数据：少量的数据，例如1，2，3，40，59等普通的数字，但是这些数字在不同的机器上可能有不同的表现形式～

* 需求：简单的跨平台的计算机程序，在任何机器上例如我输入 1+1 输出等于3，也可以定义其他计算方法和稍微复杂的计算。
* 材料：c语言
* 程序设计：
    * 1，跨平台，每台的机器的操作系统或者机器占用的位数都不一样需要有这样一个程序来申请内存然后回收内存
    * 2，每台机器的指令集可能不一样，要有一个统一的指令集，
    * 3，要可以自己编写函数，例如你把你的程序编写在一个txt上，运行程序，读取这个txt，变成机器熟悉的语言， 然后运算。

```java
  add_twoNum.txt

  func_Add(int a,int b){
    int sum;
    sum=a+b;
    out("计算结果是："+sum)；
  }
```

上面是一个txt的记事本程序，我们现在要根据这个程序用c语言写类似jvm的虚拟机，可以执行上面的程序 。当然，正常的jvm虚拟机用到是编译好的.class文件，但是我们数据量少，是下面是伪代码

```c
/* 加载文件，把代码路径读取，并且加载到虚拟机中*/
  int LoadFile(filePath *){

  }
/* 初始化运行内存  size 内存大小*/
  int IntStaticMemory(int size){

    return *Menory;
  }
/* 管理运行时的内存，包含方法区和全局堆内存。*/
  int RunMemoryMan(Menory *m ...){

  }
/*指令系统,操作类型，参数1地址，参数2地址，返回结果地址*/
  int RegisterSystem(Register register,int *word1,*int word2 ){

    return *result;
  }
/*指令计数器 目前操作操作*/
  int ProgramRunCunt(opreate o){

  }

  main(){
    int pro_runsize= LoadFile(add_twoNum);//加载文件到内存中去，
    word1,word2=IntStaticMenory(pro_runsize);//初始化内存，
    //指令运算，得到运算结果
    result *r=RegisterSystem(word1,word2);
    //得到计算结果后要进行内存回收，首先记录目前的操作
    ProgramRunCunt（stop）；
    //回收内存
    RunMemoryMan（word1*,word2*）;
    //恢复
    ProgramRunCunt（run）；
    out
  }

```

所以如果你的数据是很原始的，想运行在不同的机器上的话，请用jvm虚拟机。用过都说好！

### 1 java 源码包

###  1.1 java 容器

 时间继续推进，数据越变越多，而且从原来单一的数据，计算的方式会变得更加的复杂。因此我们需要设计一套容器工具包来处理我们的数据。但是因为数据的变化很大，例如大小，有序和无序，数据间的关系等，而我们对数据的操作也经常有增删查改，那我们需要根据数据的特点进行操作时会设计不同的容器。例如我们对大量的随机数据进行查改是会设计一个数组，对小量的有序的数据进行增删，我们希望用链表。那假如像上面说的，我们要设计3\*4=12个容器类就行了。

 当这种复杂的多样化的工具类，会存在很多冗余代码，例如一个list（队列）实现会有linklist（有序链表）和arraylist（无序列表）,但是他们可能会有

 同样的方法可能会用到，例如 isEmpty() 判断是否为空，这时候可以定义一些公共的接口，或者使用继承来封装公共的方法。

```java
/**
 * map接口，定义一个接口规范提供，根据需求存放key和value，可以根据不同的需求底层使用tree或者hash实现
 **/
  interface Map<k,v>{
   //插入,
    put(k,v);
   //删除
    delete(k);
   //修改
    replace(k,v);
   //遍历
    next();
  }
/**
 * hashmap，使用hashcode -- entry  这种数据形式实现，首先将key进行hashcode计算，key-value以entry的形式存放到一个链表里面
 * 数据里面
 **/
  class HashMap<k,v> implements Map<k,v>{
    //作为map中的单位
    Node[] table;
    //实现插入方法
    put(k,v){
      //计算hashcode
      int code=hashcode(k);
      int i = this.indexOf(key);
        Node thisNode = new Node(key, value);
        if (table[i] != null) {
            .......//如果是当前节点的头节点，则放到当前，否则遍历到链表最后追加上去
        } else {
            table[i] = this.Node;
        }

    }
    //删除
    delete(k){
      //计算hashcdode，然后找到对应到链表进行删除
      int code=hashcode(k);
      //遍历列表下面的key - value
      for(table[code]:Node){
        if(Node.key==key){
          remove(k);
        }
      }
    }
    //替换
    replace(k,v){
      ....
    }
    //遍历
    next(){

    }
  }
  /**
   * 底层用树代替
   **/
  class treeMap<k,v>{
    ......
  }

```



### 2 怎样写代码&运维

 当代码量增大时，需要对代码的逻辑进行管理，当业务逻辑变得复杂时，除了要管理计算机的逻辑，例如每次文件读取时文件的打开和关闭。对象管理，虽然已经有了jvm对对象的回收和内存释放，但是业务逻辑增多并且跟程序逻辑混在一起很容易会出bug，例如某处代码打开了文件但是忘了关闭，业务逻辑和程序逻辑混淆导致代码修改困难，一个类代码行数很长会很难维护。最近看了《effective java》正常来说应该是后面有一定的代码积累才看，但是这些作为我的编程规范吧。

### 3 多线程的使用

多线程的出现主要因为不是软件，是硬件的变化，是CPU原来从一个核变成了多个核，所以为了不把资源浪费，可以把程序做成多线程的，当然如果要写的话应该从jvm入手。假如我现在有两个核的cpu，怎样同时利用好两个核的，答案就是把一段计算的计算任务切成几块，然后用来把它放到两个核中计算，最后得出结果。而切成几块的这个块就是线程，而此时，问题就出现了，既然要切成几块，怎么切？是个问题，如果这些计算任务存在先后次序，要怎么沟通？多线程就是这样解决。

所以说多线程其实就是解决1，原子性（一块蛋糕切多大）2，顺序性（怎样切，如果同时有多把刀，会不会打架）3，可见行（就是刀与刀之间的沟通问题，如果这块蛋糕我已经切了，就要告诉后续沟通清楚）。多线程其实就是结局这些问题，而后续的分布式计算也是解决类似问题，只是运用在不同的机器间解决三个问题基础上增加其他的问题。

### 4 spring 的使用

数据除了单一维度的计算以外，还会伴随着各种意义和信息，这时候除了平时的加减乘除，还会设计简单的存储。同时，一条数据会代表不同的信息，例如我们想做一个商城的网站，具体流程如下，用户浏览商品，加入购物车，结账。商家的库存里减少商品库存，发货，交易结束。在这个过程中这时候数据除了用来计算还承担了记录信息的功能。这时候我们会引用对象来赋予数据某些信息。

```c
//商品
class product{
  //商品名称
  String name;
  //价格
  int price；
  //剩余数量
  int sum；
}
//顾客
class clustermer{
  // 名称
  String name;
  //账户
  String account;
  //账户余额
  String money;
}
//商店
class shop{
 //名称
  String name;
 //商品
  list<product>
}


```

要实现一个购物功能，至少要编写以下逻辑代码,并且希望把数据存储到硬盘上，例如一个txt文件，txt的数据结构暂时忽略

```java
//读写txt工具类，假如这个工具类已经实现了
ReadwriteTXTUtil{
  //根据产品名字获取的方法
  product readProduct(String name){
    //打开文件
    file.openfile("/userfile/product.txt");
    //读取
    product=readfile(name);
    //关闭文件
    file.close();
    return product
  }
  //写产品，把产品信息记录下来
  wreteProduct(Product product){
    //打开文件
    file.openfile("/userfile/product.txt");
    //写数据
    write(product);
  }
}

main(){

}
```

### 5 存储与数据库

### 6 分布式与大数据

### 7 机器学习
